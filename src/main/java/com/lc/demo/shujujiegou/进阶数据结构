



        1.HashCode 为什么使用 31 作为乘数
            ①哈希值在乘数 31 时，碰撞概率 相对小
            ②Hash 散列值分布 数据散列分布比较好



        2.HashMap
            HashMap 底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键 哈希值为 0。
            HashMap 并不保证键值对的顺序，这就意味着在某些操作后，键值对的顺序可能发生改变。
            另外需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。

            ①散列表的实现

            ②扰动函数
              hashmap源码里不是直接获取哈希值，还进行了一次扰动计算，（ h=key.hashCode()^(h>>>16) ）。
              把哈希值右移16位，也就正好是自己长度的一半，之后与原哈希值做异或运算，
              这样就混合了原哈希值中的高位与低位，增大了随机性。

             说白了就是，使用扰动函数是为了增加随机性，让数据元素更加均衡的散列，减少碰撞。
             数据分配均匀，也就是散列的效果更好，减少了 hash 的碰撞，让数据存放和获取的效率更佳。

            ③初始化容量
                散列数组需要一个2的倍数的长度，默认 16；因为只有 2的倍数在减一的时候，才会出现 0111（除高位以外都是 1的特征也是为了散列） 这样的值

                如果传的不是 2的倍数，会根据 初始化值 initialCapacity = 17 通过 tableSize() 方法进行计算，出 阀值 threshold ;这个方法也就是要寻找比初始值大的，最小的那个
                2的倍数的值。比如传 17 ，我们应该找到的是 32

            ④负载因子
            选择一个合理的大小进行扩容，默认值 0.75 ，也就是说当 阀值容量占了 3/4 时，就进行扩容，减小哈希碰撞。


            ⑤扩容元素拆分
                为什么扩容，因为数组长度不足了。那扩容最直接的问题，就是需要把元素拆分
                到新的数组中。拆分元素的过程中，原 jdk1.7 中会需要重新计算哈希值，但是
                到 jdk1.8 中已经进行优化，不在需要重新计算，


        3.HashMap的使用

            ①HashMap的插入

            ②扩容机制
            HashMap 是基于数组+链表和红黑树实现的，但用于存放 key 值得的数组桶的长
            度是固定的，由初始化决定。
            那么，随着数据的插入数量增加以及负载因子的作用下，就需要扩容来存放更多
            的数据。而扩容中有一个非常重要的点，就是 jdk1.8 中的优化操作，可以不需
            要再重新计算每一个元素的哈希值

            随着扩容后，原来那些因为哈希碰撞，存放成链表和红黑树的元素，都需要进行拆
            分存放到新的位置中

            ③链表树化
            HashMap 这种散列表的数据结构，最大的性能在于可以 O(1)时间复杂度定位到元
            素，但因为哈希碰撞不得已在一个下标里存放多组数据，那么 jdk1.8 之前的设
            计只是采用链表的方式进行存放，如果需要从链表中定位到数据时间复杂度就是
            O(n)，链表越长性能越差。因为在 jdk1.8 中把过长的链表也就是 8 个，优化为
            自平衡的红黑树结构，以此让定位元素的时间复杂度优化近似于 O(logn)，这样
            来提升元素查找的效率。但也不是完全抛弃链表，因为在元素相对不多的情况下，
            链表的插入速度更快，所以综合考虑下设定阈值为 8 才进行红黑树转换操作

            1. 链表树化的条件有两点；链表长度大于等于 8、桶容量大于 64，否则只是扩容，不
            会树化。
            2. 链表树化的过程中是先由链表转换为树节点，此时的树可能不是一颗平衡树。同时
            在树转换过程中会记录链表的顺序，tl.next = p，这主要方便后续树转链表和
            拆分更方便。
            3. 链表转换成树完成后，在进行红黑树的转换。先简单介绍下，红黑树的转换需要染
            色和旋转，以及比对大小。在比较元素的大小中，有一个比较有意思的方法，
            tieBreakOrder 加时赛，这主要是因为 HashMap 没有像 TreeMap 那样本身就
            有 Comparator 的实现

            ④红黑树转链表
                因为记录了链表关系，所以替换过程很容易。所以好的数据结构可以让操作变得
              更加容易
            ⑤查找
            1. 扰动函数的使用，获取新的哈希值，这在上一章节已经讲过
            2. 下标的计算，同样也介绍过 tab[(n - 1) & hash])
            3. 确定了桶数组下标位置，接下来就是对红黑树和链表进行查找和遍历操作了

            ⑥删除

            ⑦遍历
